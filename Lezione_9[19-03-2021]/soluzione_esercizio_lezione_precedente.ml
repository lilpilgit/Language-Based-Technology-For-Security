[PASSO 1]
type iexpr = 
	| Let of string * iexpr * iexpr
	| If of expr * iexpr * iexpr
	| Fun of string * iexpr
	| Call of iexpr * iexpr;;

Se uno vuole estendere con la possibilità di avere le dichiarazioni, quindi avere un blocco dove dichiaro, avere la possibilità di definire una funzione e avere la possibilità di chiamare la funzione, bisogna estendere questo linguaggio, quindi i tipi delle espressioni per contenere questi tre nuovi costrutti. Come si fa a estenderle? Bisogna introdurre i tipi algebrici che permettono di fare la dichiarazione, l'ìf then else, la dichiarazione di una funzione, il lambda e un invocazione di una funzione, quindi a questo punto il passo è esattamente quello di definire i tipi algebrici relativi, in modo particolare, definire il let definire l'if il fun e la call che rappresenteranno in termini della struttura dei tipi di dati algebrici che ci mette Ocaml, l'estensione all'albero di sintassi astratta che ci permette di descrivere sinteticamente i programmi. Il let deve prendere una stringa, l'espressione che, una volta valutata, sarà associata nell'ambiente al nome che stiamo introducendo nel let e il corpo del let. Quindi da questo punto di vista rappresenta un qualcosa dove la stringa che viene messa è sostanzialmente l' identificatore che viene introdotto. iesp rappresenta l'espressione che, una volta valutata, darà il valore alla variabile introdotta. mentre il secondo iexpr rappresenterà il corpo del let. Quindi quello che abbiamo definito è il nodo di un albero di sintassi astratta dove la radice è il costrutto che stiamo definendo "let", i sotto alberi rappresentano gli alberi di sintassi astratta relative alle caratteristiche sintattiche del costrutto che stiamo introducendo. Il primo albero di sinistra è la stringa che rappresenta l' identificatore. il sotto albero intermedio rappresenta l'espressione che una volta valutata, sarà poi utilizzata per associare il valore a quell'identificatore introdotto e la terza espressione rappresenta il corpo del let. Quindi questa è il modo di rappresentare nella nostra simulazione la sintassi del costrutto che stiamo introducendo. Similmente, per l' if, deve rappresentare un costrutto condizionale. Il costrutto condizionale lo possiamo vedere in termini di albero di sintassi astratta, come un nodo di un albero alla cui radice c'è il costrutto if e ha 3 sottoalberi. Dobbiamo introdurre a rappresentazione sintattica delle funzioni, allora la scelta che viene fatta, che le funzioni sono viste come dei lambda, come sono fatti questi lambda? Rappresenta il nodo dell'albero di sintassi astratta che rappresenta una funzione anonima. Una funzione in cui non gli è ancora dato il nome perché il meccanismo che è presente nel linguaggio per dare i nomi alle funzioni è il let che mi permette di associare a un espressione un nome. Il lambda è caratterizzato in questo esempio da una funzione che prende un argomento, una stringa e quindi sarà nell'albero di sintassi estratta il sotto albero di sinistra e il corpo della funzione, cioè quello che dovrà essere eseguito quando invochi la funzione facendo l' opportuna passaggio dei parametri e quindi anche questa sarà una espressione, quindi anche questo qui concettualmente stiamo introducendo un costrutto per rappresentare un albero di sintassi estratta con due sotto alberi. Infine la call, la call, El meccanismo di invocazione di una funzione. Allora qui siamo in un linguaggio funzionale, in un linguaggio funzionale, l', invocazione di una funzione, un qualcosa che non è soltanto andare a vedere. Cos'è associato al nome? Quello che abbiamo chiamato la denotazione di un nome, ma è il fatto che io possa avere delle espressioni che producono dinamicamente dei valori. Ad esempio possono posso tenere? Come risultato della valutazione di una funzione, posso avere un valore che corrisponde a una funzione anonima. Allora quel punto, avendo questo valore prodotto a tempo di esecuzione, posso invocare la funzione per cui la call, quindi invocazione di una funzione, è un costrutto che prende due parametri, l'espressione che una volta valutata sarà la funzione che deve essere eseguita e la seconda espressione? Che è il parametro attuale, ovvero quell espressione che, valutata nell ambiente del chiamante, dovrà poi essere associata ad un valore e questo valore sarà il valore trasmesso al codice parametrizzato della funzione che è definita da una lambda. Va bene allora questo in questo modo quello che abbiamo fatto in questo modo è quello di definire gli alberi di sintassi astratta che ci permettano sintatticamente di rappresentare un linguaggio dove ho. Interi la datazione, quindi il fatto di avere stringhe e di poter avere dei nomi associati a queste identificatori. Le operazioni primitive. E l' inferenza le dichiarazioni dei locali e le funzioni, oltre alla dichiarazione che abbiamo visto la volta scorsa degli execution monitor. Il primo passo è quello dunque di operare sulla struttura sintattica, quindi avere un meccanismo della modifica della struttura sintattica del programma per fare in modo di rappresentare a tempo di esecuzione gli alberi di sintassi astratta. Inoltre al passo 1 bisogna anche definire i valori. Cioè i valori che sono presenti a tempo di esecuzione, quindi quello che sarà il risultato della valutazione di un espressione. E noi abbiamo visto che i valori esprimibili sono o gli interi o le chiusure.	

[PASSO 2]
Il passo 2 prevede la domanda: cosa è presente nel run time? Ovvero quali sono le caratteristiche che il run time del linguaggio. deve prevedere per permettere l'esecuzione di programmi nel linguaggio. Noi abbiamo visto la volta scorsa quando abbiamo fatto vedere l'esempio sono presenti sostanzialmente 2 cose: la prima cosa è l'ambiente, l'ambiente è la struttura che ci permette di associare nomi a valori. E' la struttura che ci permette di fare l'operazione di inserire un valore in un ambiente sostanzialmente quello che ci occorre quando facciamo una let e l'operazione di andare a vedere se è presente un nome nell'ambiente, quella che abbiamo chiamato operazione di lookup, La seconda cosa che abbiamo visto la volta scorsa era che nel run time è presente la ACL che sono delle liste che mettono in evidenza quali sono le espressioni, quindi i nomi delle operazioni che si possono eseguire. Quindi una lista di nomi di operazioni che si possono eseguire. 

[PASSO 3]
match iexpr with
	| Let(string,e1,e2) -> let eval = eval(e1,env,acl) in 
										let env1 = (s,val)::env in
										eval(e2, env1, acl)

 Fatto questo, cioè il passo tre che è la definizione di eval che è l'interprete del linguaggio. eval prende un espressione, prende un ambiente, prende una lista di controllo degli accessi e mi restituisce un value. eval è semplicemente una operazione che permette di muoversi sull'albero di sintassi astratta, quindi è una visita sull albero di sintassi astratta, a seconda del nodo che incontra nell albero di sintassi astratta, fa la valutazione. Opera per pattern matching. Va a valutare se quell operazione che era era ammissibile nel contesto di quel controllo degli accessi che avevamo. Facciamo una copia locale e valutiamo localmente il parametro. In termini di strutture di runtime questo vuol dire che nel ramo di attivazione del chiamante ci sarà uno spazio che viene appositamente dedicato per contenere il valore delle elaborazioni intermedie del calcolo, in modo particolare il valore dell elaborazione intermedia del calcolo è la valutazione dell'espressione, che poi è stata associata al nuovo nome che viene introdotto. Dobbiamo introdurre il nuovo record di attivazione, ogni blocco nei linguaggi corrisponde in termini di strutture di runtime a un nuovo record di attivazione che viene messo sulla pila perché i blocchi sono delle funzioni anonime senza parametri. Allora si chiama env1 = all'ambiente che io ottengo estendendo l'ambiente che avevo prima con il legame tra la coppia S e l'ambiente che avevo al momento e questo corrisponde esattamente a fare un'operazione di push sul record di attivazione dove andrò a mettere nome s e il nuovo valore che è il valore che ho ottenuto andando a valutare e1, in eval(e2,env1,acl). Il passo successivo è valutare l'if... 
 
 
 La chiusura prende soltanto le informazioni relative all'ambiente al momento della dichiarazione, molto probabilmente va estesa la nozione di chiusura per tener conto anche di quali sono il controllo degli accessi al momento della dichiarazione, quindi vuol dire che bisogna tener conto di questa informazione, visto che abbiamo interiorizzato all'interno del calcolo il controllo degli accessi e quindi vuol dire che questa implementazione va bene relativamente alla gestione dei nomi dell'ambiente, ma bisogna tener conto anche di questa operazione. La ACL non è definita staticamente, la ACL essendo un costrutto a livello del linguaggio, sarà programmata. Noi quello che abbiamo fatto con questo esempio abbiamo posto non una lista di controllo statica, ma abbiamo visto la possibilità di definirci da programma quali sono quelle porzioni di codice che vale. La scelta che viene fatta è una scelta che dice: i nomi sono visti staticamente, ma il controllo degli accessi è visto dinamicamente, cioè il controllo degli accessi dipende dal momento in cui siamo. Allora ci potrebbe essere un'altra scelta che il controllo degli accessi dipende dal momento in cui la funzione viene dichiarata, se si fa questa seconda scelta, allora bisogna cambiare la chiusura. Bisogna vedere come si amalgama la sicurezza in questo caso vista come lista di controllo degli accessi sulla politica di visibilità dei nomi. Quella che vi ho fatto vedere io è una scelta, ce n'è anche un'altra.